<!--------------------------------------------------------------------------->
<!--                           INTRODUCTION                                

 The Code Project article submission template (HTML version)

Using this template will help us post your article sooner. To use, just 
follow the 3 easy steps below:
 
     1. Fill in the article description details
     2. Add links to your images and downloads
     3. Include the main article text

That's all there is to it! All formatting will be done by our submission
scripts and style sheets. 

-->
<!--------------------------------------------------------------------------->
<!--                        IGNORE THIS SECTION                            --><html><head>
		<title>The Code Project</title>
		<STYLE> BODY, P, TD { font-family: Verdana, Arial, Helvetica, sans-serif; font-size: 10pt }
	H2,H3,H4,H5 { color: #ff9900; font-weight: bold; }
	H2 { font-size: 13pt; }
	H3 { font-size: 12pt; }
	H4 { font-size: 10pt; color: black; }
	PRE { BACKGROUND-COLOR: #FBEDBB; FONT-FAMILY: "Courier New", Courier, mono; WHITE-SPACE: pre; }
	CODE { COLOR: #990000; FONT-FAMILY: "Courier New", Courier, mono; }
	</STYLE>
		<link href="http://www.codeproject.com/styles/global.css" type="text/css" rel="stylesheet"></head>
	<body bgColor="#ffffff" color="#000000">
		<!--------------------------------------------------------------------------->
		<!-------------------------------     STEP 1      --------------------------->
		<!--  Fill in the details (CodeProject will reformat this section for you) --><pre>Title:       Spheres in GDI+ 
Author:      Alessio Saltarin 
Email:       AlessioSaltarin@hotmail.com
Environment: Visual Studio.NET, C#
Keywords:    GDI+, Sphere, Conversions, Viewport
Level:       Intermediate
Description: Using GDI+ to draw spheres in a 2D environment
Section      General C#
SubSection   Multimedia
</pre>
		<!-------------------------------     STEP 2      --------------------------->
		<!--  Include download and sample image information.                       -->
		<ul class="download">
			<li>
				<A href="SpheresGDI_/SpheresGDI+.zip">Download demo project - 147 Kb </A>
			<li>
				<A href="SpheresGDI_/SpheresGDI+_src.zip">Download source - 6 Kb</A>
			</li>
		</ul>
		<p><IMG alt="Sample Image - maximum width is 600 pixels" src="SpheresGDI+.gif"></p>
		<!-------------------------------     STEP 3      --------------------------->
		<!--  Add the article text. Please use simple formatting (<h2>, <p> etc)   -->
		<h2>Introduction</h2>
		<p>During the development of a videogame skeleton, one of my biggest concern was 
			the drawing of a large interstellar map. Since it was just a skeleton, 
			implementing 3D graphics with OpenGL or Direct3D was not an option. I soon 
			discovered that GDI+ could very well fit my needs. So I had to face mainly two 
			issues:</p>
		<UL>
			<li>
			While .NET panels reason in terms of "pixels", my map was based on some "light 
			years" metrical units.
			<LI>
				I had to imagine an algorithm to easily paint a sphere (or spheroid) on that 
				map</LI></UL>
		<P>The included code show how we solved those problems. It could be helpful to show 
			how easy is to add graphics and shapes using GDI+ and .NET.</P>
		<h2>Conversion between "pixel" geometry and "logical units" geometry</h2>
		<p>When we want to display something using GDI+, we must reason in terms of pixels. 
			The <code>Graphics</code> object&nbsp;can be obtained by calling the <code>CreateGraphics</code>
			method from any inherited WinForm control. So, for instance, a Panel is an 
			optimal choice as a drawing surface, much better than the form itself. When a 
			Graphics object is initialized, it's geometry is based on the pixel displayed, 
			being (0,0) the left-upper corner of it.</p>
		<P>If I must draw a line, say, from the point (10,10) to the point (30,30) I must 
			call:</P>
		<PRE lang=cs>//
// The main Graphics object
//
Graphics panelGraphics = this.panel.CreateGraphics();
panelGraphics.DrawLine(new Pen(Color.Black,0.2F),10,10,30,30);
</PRE>
		<p>Since every&nbsp;method and property of GDI+ is based on pixels, drawing items 
			in terms of some other&nbsp;unit of measure implies a conversion. Also, when we 
			use "real world" formulas, they must be adapted to the "pixel" logic. Instead 
			of spreading the conversions throughout the code, a class is what it's needed.</p>
		<P><IMG alt="" src="gridview_UML.gif"></P>
		<P>The GridView class provides the methods to pass from a "pixel" geometry to some 
			other "logical units" geometry. So, when you have to draw a rectangle with a 
			width of 4.5 cm and an height of 3.0 cm to a 400x500 panel, all you have to do 
			is:</P>
		<UL>
			<li>
				Initialize <code>GridView</code>
			with desired&nbsp;width of panel in logical units (if you want to 
			display&nbsp;the 4.5&nbsp;wide rectangle, a logicalW parameter of 10.0 seems 
			perfect)
			<LI>
				Pass your panel size in pixel</LI></UL>
		<P>In the case above the <code>GridView</code> will be constructed with</P>
		<pre lang=cs>//
// GridView initialized for a 400x500 pixel panel of 10.0 cm wide
//
GridView gv = new GridView(10.0,400,500);
</pre>
		<P>Now, if you want to know how many pixel in this panel a rectangle of 4.5 cm wide 
			is in pixels, or if you want to know where the point (1.2cm,2.4cm) is, you may 
			use:</P>
		<pre lang=cs>//
// Conversions
//
int pixelWidth = gv.getPhysicalWidth(4.5);
int pX = gv.getPhysicalX(1.2);
int pY = gv.getPhysicalY(2.4);
</pre>
		<P>&nbsp;</P>
		<H2>Drawing spheres</H2>
		<p>
			When the <code>GridView</code>
		is initialized, the panel has now 2D cartesian axis (in the downloadable example, the length of them is 5.0 and the coordinates are displayed 
		on top right).
		<P>An object of the class <code>Sphere</code> can be initialized like below:</P>
		<pre lang=cs>
//
// Initializing Sphere object
//
Sphere s1 = new Sphere(gv,r,this.centerX,this.centerY);
s1.SphereColor=this.txtColor.BackColor;
</pre>
		<p>where
			<UL>
				<li>
					<code>gv</code>
				is the initialized GridView object
				<li>
					<code>r</code>
				is the sphere radius
				<li>
					<code>centerX</code>
				is the X coordinate of the center (in logical units)
				<li>
					<code>centerY</code> is the Y coordinate of the center (in logical units)
				</li>
			</UL>
		<P>The algorithm for drawing the sphere is very simple, and it is based on drawing 
			arcs in a rectangle whose dimensions shrink. The algorithm draws the arcs first 
			from right to left, then from top to bottom.</P>
		<pre lang=cs>
private void drawArcs(Graphics g, Pen color, Rectangle r)
{

	int x1=r.Left+r.Width/2;
	int y1=r.Top;
	int x2=x1;
	int y2=r.Top+r.Height;

	int x3=r.Left;
	int y3=r.Top+r.Height/2;
	int x4=r.Left+r.Width;
	int y4=y3;

	// draw axis
	g.DrawLine(color,x1,y1,x2,y2);
	g.DrawLine(color,x3,y3,x4,y4);

	// right-left arcs
	for (int j=r.Width; j&gt;0; j-=10)
	{
		int left = r.Left+(r.Width-j)/2;
		Rectangle rc = new Rectangle(left,r.Top,j,r.Height);
		g.DrawArc(color,rc,0.0F,180.0F); // 0-180 degrees
		g.DrawArc(color,rc,180.0F,360.0F); // 180-360 degrees
	}
	// top-bottom arcs
	for (int j=r.Height; j&gt;0; j-=10)
	{
		int top = r.Top+(r.Height-j)/2;
		Rectangle rc = new Rectangle(r.Left,top,r.Width,j);
		g.DrawArc(color,rc,270.0F,450.0F); // 270-90 degrees
		g.DrawArc(color,rc,90.0F,270.0F); // 90-270 degrees
	}

}
</pre>
		<P>Modifying the number of loops (j-=10) you can obtain finer wires. You can also 
			modify the width of the Pen in order to get different results.</P>
		<h2>Point of Interest</h2>
		<p>When you draw something on a Control, on a Panel in this case, if you cover the 
			control with another control (or another window), the contents just drawn 
			disappears. For this reason, every new sphere that you draw is collected into 
			an ArrayList collection. Whenever the <code>paint</code> event is raised, I 
			call the <code>paint</code> method for every shape in the collection. 
			<!-------------------------------    That's it!   ---------------------------></p>
	</body>
</html>
